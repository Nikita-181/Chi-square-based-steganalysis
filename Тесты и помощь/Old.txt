using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Channels;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Navigation;
using System.Windows.Shapes;
using static System.Reflection.Metadata.BlobBuilder;
using System.Diagnostics.Metrics;
using System.Security.Policy;
using static System.Net.Mime.MediaTypeNames;
using System.IO;
using Microsoft.Win32;
using System.Diagnostics;
using System.Drawing.Imaging;

double[] chiSquareAttackTopToBottom(Bitmap image)
{
    int imgWidth = image.Width;
    int imgHeight = image.Height;
    //получаем каналы 
    var channels = BitmapToByteRgb(image);

    double[] pVals = new double[imgHeight];
    //Анализ идет построчно, увеличивая колическво строк на 1 за цикл
    for (int i = 0; i < imgHeight; i++)
    {
        //вычисляем частоту появления цвета
        float[] cropHist = new float[256];
        for (int j = 0; j < 256; j++)//ставим единички, чтобы не делить на 0
        {
            cropHist[j] = 1;
        }

        //Высчитываем суммарную гистограмму по 3м каналам  
        for (int h = 0; h <= i; h++)
        {
            for (int w = 0; w < imgWidth; w++)
            {
                cropHist[channels[h, w, 0]] += 1;
                cropHist[channels[h, w, 1]] += 1;
                cropHist[channels[h, w, 2]] += 1;
            }
        }

        //высчитывам наблюдаемую и ожидаемую частоту
        //expected и observed делять длину исследуемой последовательности пополам
        //так как у нас 256 цветов, то создаем 2 массива по 128 элементов
        double[] expected = new double[128];
        int[] observed = new int[128];
        for (int k = 0; k < cropHist.Length / 2; k++)
        {
            expected[k] = (cropHist[2 * k] + cropHist[2 * k + 1]) / 2;
            observed[k] = Convert.ToInt32(cropHist[2 * k + 1]);
        }

        //Если количество пикселей цвета 2k и 2k+1 будет сильно различаться,
        //то различаться будут измеренная частота и теоретически ожидаемая,
        //что нормально для незаполненного стегоконтейнера.

        //Считаем вероятность "p" исследуемой посследовательности
        var chi = chiSquare(expected, observed);//вычисляем Хи-квадрат
        int df = observed.Length - 1;//степени свободы
        var pVal = ChiSquarePval(chi, df);
        pVals[i] = pVal;
    }
    return pVals;
}

double[] chiSquareAttackTopToBottomEMGUCV(Image<Rgb, Byte> image)
{
    int imgWidth = image.Width;
    int imgHeight = image.Height;
    //получаем каналы 
    var channels = image.Split();
    //var habrchan = BitmapToByteRgb(image.ToBitmap());
    //int error = 0;
    //for (int i = 0; i < imgHeight; i++)
    //{
    //    for(int j = 0;j < imgWidth; j++)
    //    {
    //        if (channels[0].Data[i,j,0] != habrchan[i,j,0])
    //        {
    //            error = 1;
    //        }
    //        if (channels[1].Data[i, j, 0] != habrchan[i, j, 1])
    //        {
    //            error = 1;
    //        }
    //        if (channels[2].Data[i, j, 0] != habrchan[i, j, 2])
    //        {
    //            error = 1;
    //        }
    //    }
    //}

    double[] pVals = new double[imgHeight];
    //Анализ идет построчно, увеличивая колическво строк на 1 за цикл
    for (int i = 0; i < imgHeight; i++)
    {
        //вычисляем частоту появления цвета
        float[] cropHist = new float[256];
        for (int j = 0; j < 256; j++)//ставим единички, чтобы не делить на 0
        {
            cropHist[j] = 1;
        }

        ////var cropRect = new System.Drawing.Rectangle(0, i, imgWidth, 1);//построчно
        //var cropRect = new System.Drawing.Rectangle(0, 0, imgWidth, i + 1);//увеличивая зону
        //Image<Rgb, Byte> rgb = image;
        //rgb.ROI = cropRect;
        //Image<Rgb, Byte> rgb_crop = rgb.CopyBlank();
        //rgb.CopyTo(rgb_crop);
        //rgb.ROI = System.Drawing.Rectangle.Empty;
        //var corp_channels = rgb_crop.Split();
        //int crop_Height = rgb_crop.Height;
        //int crop_Width = rgb_crop.Width;

        //Высчитываем суммарную гистограмму по 3м каналам  
        foreach (var ch in channels)
        {
            for (int h = 0; h <= i; h++)
            {
                for (int w = 0; w < imgWidth; w++)
                {
                    cropHist[ch.Data[h, w, 0]] += 1;
                }
            }
        }

        //высчитывам наблюдаемую и ожидаемую частоту

        List<double> expected = new List<double>();
        List<int> observed = new List<int>();
        for (int k = 0; k < cropHist.Length / 2; k++)
        {
            expected.Add((cropHist[2 * k] + cropHist[2 * k + 1]) / 2);
            observed.Add(Convert.ToInt32(cropHist[2 * k + 1]));
        }

        //Если количество пикселей цвета 2k и 2k+1 будет сильно различаться,
        //то различаться будут измеренная частота и теоретически ожидаемая,
        //что нормально для незаполненного стегоконтейнера.

        //Считаем вероятность "p" исследуемой посследовательности
        var chi = chiSquare(expected.ToArray(), observed.ToArray());//вычисляем Хи-квадрат
                                                                    // var chi2 = ChiFromFreqs(observed.ToArray(), expected.ToArray());//вычисляем Хи-квадрат
        int df = observed.Count - 1;//степени свободы
        var pVal = ChiSquarePval(chi, df);

        //pVals.Add(pVal);
        pVals[i] = pVal;
        //очищаем память
        //rgb_crop.Dispose();
    }
    return pVals;
}
